// internal/core/emulation/executor.go

package emulation

import (
    "cyberditto-backend/pkg/vagrant"
    "cyberditto-backend/internal/core/deploy"  
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "time"
    "log"
)

type Executor struct {
    vagrant *vagrant.Manager
    projectRoot string
    deployService *deploy.Service  
}

func NewExecutor(vagrant *vagrant.Manager, projectRoot string, deployService *deploy.Service) *Executor {
    return &Executor{
        vagrant:      vagrant,
        projectRoot:  projectRoot,
        deployService: deployService,
    }
}

func (e *Executor) Execute(config ExecutionConfig) (*ExecutionResult, error) {
    // First get deployment info to get the VagrantID
    deployStatus, err := e.deployService.GetStatus(config.DeploymentID)
    if err != nil {
        return nil, fmt.Errorf("failed to get deployment info: %v", err)
    }

    if deployStatus.VagrantID == "" {
        return nil, fmt.Errorf("no vagrant ID found for deployment %s", config.DeploymentID)
    }

    // Get VM information and verify it's running using VagrantID
    status, err := e.vagrant.GetStatus(deployStatus.VagrantID)
    if err != nil {
        return nil, fmt.Errorf("failed to get VM status: %v", err)
    }
    
    if status != "running" {
        return nil, fmt.Errorf("VM must be running to execute tests (current status: %s)", status)
    }

    // Create execution directory
    execDir := filepath.Join(config.OutputPath, fmt.Sprintf("exec_%d", time.Now().UnixNano()))
    if err := os.MkdirAll(execDir, 0755); err != nil {
        return nil, fmt.Errorf("failed to create execution directory: %v", err)
    }

    // Generate script
    scriptPath := filepath.Join(execDir, "attack.ps1")
    if err := e.generateScript(config, scriptPath); err != nil {
        return nil, fmt.Errorf("failed to generate script: %v", err)
    }

    // Copy script to VM using VagrantID
    remoteScriptPath := fmt.Sprintf("C:\\AtomicScripts\\attack_%d.ps1", time.Now().UnixNano())
    if err := e.copyToVM(deployStatus.VagrantID, scriptPath, remoteScriptPath); err != nil {
        return nil, fmt.Errorf("failed to copy script to VM: %v", err)
    }

    // Execute script
    logPath := filepath.Join(execDir, "execution.log")
    if err := e.executeOnVM(deployStatus.VagrantID, remoteScriptPath, logPath); err != nil {
        return nil, fmt.Errorf("failed to execute script: %v", err)
    }

    // Collect results
    resultsPath := filepath.Join(execDir, "results.csv")
    if err := e.collectResults(deployStatus.VagrantID, resultsPath); err != nil {
        return nil, fmt.Errorf("failed to collect results: %v", err)
    }

    return &ExecutionResult{
        ResultsPath: resultsPath,
        LogPath:     logPath,
        Error:       nil,
    }, nil
}

func (e *Executor) generateScript(config ExecutionConfig, scriptPath string) error {
    var templateName string
    
    switch config.Mode {
    case ModeTactic:
        templateName = "tactic.ps1"
    case ModeTechnique:
        templateName = "technique.ps1"
    case ModeCustom:
        templateName = "custom.ps1"
    default:
        return fmt.Errorf("invalid mode: %s", config.Mode)
    }

    // Read template from script directory
    templatePath := filepath.Join(e.projectRoot, "scripts", "attack_templates", templateName)
    template, err := os.ReadFile(templatePath)
    if err != nil {
        return fmt.Errorf("failed to read template: %v", err)
    }

    // Prepare script content
    scriptContent := fmt.Sprintf(`
# Generated by CyberDitto at %s
$ErrorActionPreference = "Continue"
$ProgressPreference = "SilentlyContinue"

# Parameters
$Target = "%s"
$TestNumbers = "%s"
$OutputPath = "C:\AtomicResults"

%s`, time.Now().Format(time.RFC3339), config.Target, config.TestNumbers, string(template))

    return os.WriteFile(scriptPath, []byte(scriptContent), 0644)
}

func (e *Executor) copyToVM(vagrantID string, localPath, remotePath string) error {
    log.Printf("Copying script from %s to VM %s at %s", localPath, vagrantID, remotePath)
    
    vagrantCmd := fmt.Sprintf(`
        echo "Copying file to VM..."
        vagrant upload "%s" "%s" 
        if ($LASTEXITCODE -ne 0) { 
            throw "Failed to copy file to VM"
        }`, localPath, remotePath)

    cmd := exec.Command("powershell", "-Command", vagrantCmd)
    cmd.Dir = filepath.Join(e.projectRoot, "vagrant", vagrantID)
    
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("copy failed: %v, output: %s", err, string(output))
    }
    
    log.Printf("Successfully copied script to VM")
    return nil
}

func (e *Executor) executeOnVM(vagrantID string, scriptPath string, logPath string) error {
    log.Printf("Executing script on VM %s: %s", vagrantID, scriptPath)
    
    vagrantCmd := fmt.Sprintf(`
        echo "Starting script execution..."
        vagrant powershell -c "
            Set-ExecutionPolicy Bypass -Scope Process -Force
            $output = & '%s' *>&1
            $output | Out-File -FilePath '%s' -Encoding UTF8
            if ($LASTEXITCODE -ne 0) {
                throw 'Script execution failed'
            }
        "`, scriptPath, logPath)

    cmd := exec.Command("powershell", "-Command", vagrantCmd)
    cmd.Dir = filepath.Join(e.projectRoot, "vagrant", vagrantID)
    
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("execution failed: %v, output: %s", err, string(output))
    }
    
    log.Printf("Successfully executed script on VM")
    return nil
}

func (e *Executor) collectResults(vagrantID string, localPath string) error {
    log.Printf("Collecting results from VM %s to %s", vagrantID, localPath)
    
    vagrantCmd := fmt.Sprintf(`
        echo "Collecting results..."
        vagrant download "C:\AtomicResults\*\atomic_results.csv" "%s"
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to collect results"
        }`, localPath)

    cmd := exec.Command("powershell", "-Command", vagrantCmd)
    cmd.Dir = filepath.Join(e.projectRoot, "vagrant", vagrantID)
    
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("results collection failed: %v, output: %s", err, string(output))
    }
    
    log.Printf("Successfully collected results from VM")
    return nil
}

func (e *Executor) cleanup(vagrantID string, remoteScriptPath string) error {
    log.Printf("Cleaning up resources on VM %s", vagrantID)
    
    vagrantCmd := fmt.Sprintf(`
        echo "Cleaning up..."
        vagrant powershell -c "
            Remove-Item -Path '%s' -Force -ErrorAction SilentlyContinue
            Remove-Item -Path 'C:\AtomicResults\*' -Recurse -Force -ErrorAction SilentlyContinue
        "`, remoteScriptPath)

    cmd := exec.Command("powershell", "-Command", vagrantCmd)
    cmd.Dir = filepath.Join(e.projectRoot, "vagrant", vagrantID)
    
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("cleanup failed: %v, output: %s", err, string(output))
    }
    
    log.Printf("Successfully cleaned up VM resources")
    return nil
}